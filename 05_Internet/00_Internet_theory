OSI七层模型 --> 网络通信工作流程
（软件主要研究操作前四层）
1. 应用层：提供用户服务，具体功能由特定的程序而定
2. 表示层：数据的压缩优化，加密
3. 会话层：建立应用级的链接，选择传输服务
4. 传输层：提供不同的传输服务，流量控制
（后面三层开始需要由硬件来实现完成）
5. 网络层：路由选择，网络互联
6. 链路层：进行数据转换，具体消息的发送，链路连接
7. 物理层：物理硬件，接口设定，网卡路由交换机等

*高内聚，低耦合：模块功能尽可能单一，不要参杂；模块之间尽可能减少关联和影响

OSI七层模型优点：1. 将工作流程标准化 2. 降低了模块间的耦合度，使每一个部分可以单独开发，单独工作

（实际应用的时候进行来步骤合并）
四层模型：
应用层
传输层
网络层
物理链路层

五层模型（TCP/IP 模型）：
应用层
传输层
网络层
链路层
物理层

数据传输流程：
1. 发送端由应用层到物理层逐层添加信息头在首部，最终在物理层发送
2. 中间经过节点（交换机，路由器等）转发， 发送到接收端
3. 在接收端根据发送端的每个信息头进行解析，最终消息到应用层展示给用户

网络协议：在网络通信中，双方都遵循的规定。包括建立什么样都网络结构，消息结构，标示代表什么等

应用层：TFTP HTTP DNS SMTP
传输层：TCP UDP
网络层：IP
物理层：IEEE

------------------------------------------------网络相关概念------------------------------------------------------

网络主机（host）：在网络中标识一台计算机

本地使用：127.0.0.1 -> localhost

网络使用：0.0.0.0 自动选择一个合适或本机的IP地址    （查看本机当IP地址：linux/unix -> command 'if config'）

获取计算机名:
    >>> import socket
    >>> socket.gethostname()
    'Ethans-MBP.mshome.net'
通过计算机名获取地址：
    >>> socket.gethostbyname('localhost')
    '127.0.0.1'

IP地址：网络上确定一台主机的地址

IPv4: 点分十进制 -> 192.168.1.2 （每个点后取值范围 0--255，最大占32位 -> 2^32个地址）
IPv6: 128位

测试一个IP地址是否联通：command 'ping IP'   ping自己的IP，延迟很低

特殊的IP地址： 
    127.0.0.1       本机
    0.0.0.0         本机可用IP
    192.168.1.0     网段IP
    192.168.1.1     网关IP
 
通过地址获取主机网络信息：
>>> socket.gethostbyaddr('www.google.com')
('syd15s06-in-f4.1e100.net', ['68.167.217.172.in-addr.arpa'], ['172.217.167.68'])
(            主机名                         别名                     网络地址      )

将IP地址转换成hex和逆转：
>>> socket.inet_aton('192.168.1.2')
b'\xc0\xa8\x01\x02'
>>> socket.inet_ntoa(b'\xc0\xa8\x01\x02')
'192.168.1.2'

域名：网络服务器地址的名称：
172.217.167.68 -> www.google.com

网络端口号：
端口是网络地址的一部分，用于区分一个网络主机上的网络应用
*在一个操作系统中不同的网络应用监听不同的端口号
取值范围：1--65535  *众所周知的通用端口：1--255 http一般监听80  *系统应用端口：256--1023  *自用端口：1024--65535（一些有名的程序还是会使用这些端口）
端口不能与其它重复，建议使用>10000 

获取一个应用的端口信息：
>>> socket.getservbyname('ssh')
22
>>> socket.getservbyname('http')
80

网络字节序：数据在网络中的传输格式

------------------------------------------------传输层------------------------------------------------------
面向连接的传输服务：
基于TCP协议的数据传输
传输特征：提供可靠的数据传输（可靠性指数据传输过程中无丢失，无失序，无差错，无重复）
实现手段：数据传输断开前都需要进行传输和断开的确认
三次握手：TCP传输在数据传输前建立连接的过程 （详情见->TCP_三次握手.png）
    1. 客户端向服务器发送连接请求
    2. 服务器收到请求后，回复确认消息，表示允许连接
    3. 客户端收到服务器回复，进行最终标志发送确认连接
四次挥手：TCP传输在连接断开前断开确认的过程 （详情见->TCP_四次挥手.png）
    1. 主动方发送报文告知被动方要断开连接
    2. 被动方收到请求后立即返回报文告知已经准备断开
    3. 被动方准备就绪后再次发送报文告知可以断开
    4. 主动方发送消息确认最终断开
应用情况：适用于传输较大的文件，网络情况良好，需要保证传输可靠性的情况，比如：网页获取，文件下载，邮件传输，登陆注册 

面向无连接的传输服务：
基于UDP协议的传输
传输特征：不保证传输的可靠性，传输过程没有连接和断开的流程，数据收发自由
应用情况：网络情况较差，对传输可靠性要求不高，需要提升传输效率。不变连接，需要灵活收发消息，比如网络视频，群聊，广播发送

------------------------------------------------socket套接字编程（在应用层）------------------------------------------------------
目标：根据socket模块提供的接口函数，进行组合使用完成基于TCP或UDP的网络编程

套接字(socket)：完成上述目标的一种编程手段，编程方案
套接字(socket)分类：
    流式套接字(SOCK_STREAM)：传输层基于TCP协议的套接字编程方案
    数据报套接字(SOCK_DGRAM)：传输层基于UDP协议的套接字编程方案
    底层套接字(SOCK_RAM)：访问底层协议的套接字编程（一般用不到）
    * 面向连接的传输->TCP协议->可靠->流式套接字
    * 面向无连接传输->UDP协议->不可靠->数据报套接字

TCP套接字服务端编程：（详情见—>TCP_Server.png) （代码->TCP_Server.py）:
import socket（*必须import这个lib，才能调用socket方程）
1. 创建套接字
    sockfd = socket.socket(socket_family = AF_INET, socket_type = SOCK_STREAM, proto = 0)
    功能：创建套接字
    参数：
        socket_family -> 选择地址族类型 (AF_INET：进行IPv4的网络通信)
        socket_type -> 套接字类型   SOCK_STREAM 与 SOCK_DGRAM
        proto -> 选择子协议类型（TCP和UDP没有子协议，所以网络编程这里通常为0）
    返回值：返回套接字对象
2. 绑定服务端地址
    sockfd.bind(addr)
    功能：绑定IP地址
    参数：元祖(tuple) -> (ip, port)
    *此处ip：
        localhost 可以被本机用
        192.168.205.127 可以被所有人用192.168.205.127访问
        0.0.0.0 可以被所有人用192.168.127访问， 也可被localhost访问
3. 设置监听套接字
    sockfd.listen(n)
    功能：将套接字设置为监听套接字，创建监听队列
    参数：n表示监听队列大小
    * 一个监听套接字可以连接多个客户端套接字
4. 等待处理客户端连接请求
    connfd, addr = sockfd.accept()
    功能：阻塞等待处理客户端连接
    返回值：connfd->客户端连接套接字    addr->连接的客户端地址
    *阻塞函数：程序运行过程中遇到阻塞函数则暂停运行，直到某种阻塞条件达成再继续运行
5. 消息收发
    data = connfd.recv(buffersize)
    功能：接收对应客户端消息
    参数：buffersize -> 一次最多接收多少字节
    返回值：接收到到内容
    *如果没有消息则会阻塞
    n = connfd.send(data)
    功能：发送消息给对应客户端
    参数：要发送到内容，必须是bytes格式
    返回值：返回实际发送消息的大小
6.关闭套接字
    sockfd.close()
    功能：关闭套接字

TCP套接字客户端编程：（详情见—>TCP_Client.png) （代码->TCP_Client.py）:
1. 创建套接字
    *必须相同类型的套接字才能通信
2. 建立连接
    sockfd.connect(servr_addr)
    功能：建立连接
    参数：tuple -> addr
3. 消息收发
4. 关闭套接字

TCP_Server总结：
socket() ---> bind() ---> listen() ---> accept() --->recv/send ---> close()
TCP_Client总结：
socket() ---> connect() ---> send/recv ---> close()

------------------------------------------------socket套接字传输注意事项------------------------------------------------------
1. listen socket存在时，client即可发起连接，但是最终连接处理需要accept进行处理
2. 如果连接的另一端退出， 则recv会立即返回空子串不在阻塞
3. 当连接当另一端退出的时候， 再试图send就会产生BrokenPipeError