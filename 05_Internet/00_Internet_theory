------------------------------------------------网络模型------------------------------------------------------
OSI七层模型 --> 网络通信工作流程
（软件主要研究操作前四层）
1. 应用层：提供用户服务，具体功能由特定的程序而定
2. 表示层：数据的压缩优化，加密
3. 会话层：建立应用级的链接，选择传输服务
4. 传输层：提供不同的传输服务，流量控制
（后面三层开始需要由硬件来实现完成）
5. 网络层：路由选择，网络互联
6. 链路层：进行数据转换，具体消息的发送，链路连接
7. 物理层：物理硬件，接口设定，网卡路由交换机等

*高内聚，低耦合：模块功能尽可能单一，不要参杂；模块之间尽可能减少关联和影响

OSI七层模型优点：1. 将工作流程标准化 2. 降低了模块间的耦合度，使每一个部分可以单独开发，单独工作

（实际应用的时候进行来步骤合并）
四层模型：
应用层
传输层
网络层
物理链路层

五层模型（TCP/IP 模型）：
应用层
传输层
网络层
链路层
物理层

数据传输流程：
1. 发送端由应用层到物理层逐层添加信息头在首部，最终在物理层发送
2. 中间经过节点（交换机，路由器等）转发， 发送到接收端
3. 在接收端根据发送端的每个信息头进行解析，最终消息到应用层展示给用户

网络协议：在网络通信中，双方都遵循的规定。包括建立什么样都网络结构，消息结构，标示代表什么等

应用层：TFTP HTTP DNS SMTP
传输层：TCP UDP
网络层：IP
物理层：IEEE

------------------------------------------------网络相关概念------------------------------------------------------

网络主机（host）：在网络中标识一台计算机

本地使用：127.0.0.1 -> localhost

网络使用：0.0.0.0 自动选择一个合适或本机的IP地址    （查看本机当IP地址：linux/unix -> command 'if config'）

获取计算机名:
    >>> import socket
    >>> socket.gethostname()
    'Ethans-MBP.mshome.net'
通过计算机名获取地址：
    >>> socket.gethostbyname('localhost')
    '127.0.0.1'

IP地址：网络上确定一台主机的地址

IPv4: 点分十进制 -> 192.168.1.2 （每个点后取值范围 0--255，最大占32位 -> 2^32个地址）
IPv6: 128位

测试一个IP地址是否联通：command 'ping IP'   ping自己的IP，延迟很低

特殊的IP地址： 
    127.0.0.1       本机
    0.0.0.0         本机可用IP
    192.168.1.0     网段IP
    192.168.1.1     网关IP
 
通过地址获取主机网络信息：
>>> socket.gethostbyaddr('www.google.com')
('syd15s06-in-f4.1e100.net', ['68.167.217.172.in-addr.arpa'], ['172.217.167.68'])
(            主机名                         别名                     网络地址      )

将IP地址转换成hex和逆转：
>>> socket.inet_aton('192.168.1.2')
b'\xc0\xa8\x01\x02'
>>> socket.inet_ntoa(b'\xc0\xa8\x01\x02')
'192.168.1.2'

域名：网络服务器地址的名称：
172.217.167.68 -> www.google.com

网络端口号：
端口是网络地址的一部分，用于区分一个网络主机上的网络应用
*在一个操作系统中不同的网络应用监听不同的端口号
取值范围：1--65535  *众所周知的通用端口：1--255 http一般监听80  *系统应用端口：256--1023  *自用端口：1024--65535（一些有名的程序还是会使用这些端口）
端口不能与其它重复，建议使用>10000 

获取一个应用的端口信息：
>>> socket.getservbyname('ssh')
22
>>> socket.getservbyname('http')
80

网络字节序：数据在网络中的传输格式

------------------------------------------------传输层------------------------------------------------------
面向连接的传输服务：
基于TCP协议的数据传输
传输特征：提供可靠的数据传输（可靠性指数据传输过程中无丢失，无失序，无差错，无重复）
实现手段：数据传输断开前都需要进行传输和断开的确认
三次握手：TCP传输在数据传输前建立连接的过程 （详情见->TCP_三次握手.png）
    1. 客户端向服务器发送连接请求
    2. 服务器收到请求后，回复确认消息，表示允许连接
    3. 客户端收到服务器回复，进行最终标志发送确认连接
四次挥手：TCP传输在连接断开前断开确认的过程 （详情见->TCP_四次挥手.png）
    1. 主动方发送报文告知被动方要断开连接
    2. 被动方收到请求后立即返回报文告知已经准备断开
    3. 被动方准备就绪后再次发送报文告知可以断开
    4. 主动方发送消息确认最终断开
应用情况：适用于传输较大的文件，网络情况良好，需要保证传输可靠性的情况，比如：网页获取，文件下载，邮件传输，登陆注册 

面向无连接的传输服务：
基于UDP协议的传输
传输特征：不保证传输的可靠性，传输过程没有连接和断开的流程，数据收发自由
应用情况：网络情况较差，对传输可靠性要求不高，需要提升传输效率。不变连接，需要灵活收发消息，比如网络视频，群聊，广播发送

------------------------------------------------socket套接字编程------------------------------------------------------
目标：根据socket模块提供的接口函数，进行组合使用完成基于TCP或UDP的网络编程

套接字(socket)：完成上述目标的一种编程手段，编程方案
套接字(socket)分类：
    流式套接字(SOCK_STREAM)：传输层基于TCP协议的套接字编程方案
    数据报套接字(SOCK_DGRAM)：传输层基于UDP协议的套接字编程方案
    底层套接字(SOCK_RAM)：访问底层协议的套接字编程（一般用不到）
    * 面向连接的传输->TCP协议->可靠->流式套接字
    * 面向无连接传输->UDP协议->不可靠->数据报套接字

一· TCP套接字服务端编程：（详情见—>TCP_Server.png) （代码->TCP_Server.py）
import socket（*必须import这个lib，才能调用socket方程）
1. 创建套接字
    sockfd = socket.socket(socket_family = AF_INET, socket_type = SOCK_STREAM, proto = 0)
    功能：创建套接字
    参数：
        socket_family -> 选择地址族类型 (AF_INET：进行IPv4的网络通信)
        socket_type -> 套接字类型   SOCK_STREAM 与 SOCK_DGRAM
        proto -> 选择子协议类型（TCP和UDP没有子协议，所以网络编程这里通常为0）
    返回值：返回套接字对象
2. 绑定服务端地址
    sockfd.bind(addr)
    功能：绑定IP地址
    参数：元祖(tuple) -> (ip, port)
    *此处ip：
        localhost 可以被本机用
        192.168.205.127 可以被所有人用192.168.205.127访问
        0.0.0.0 可以被所有人用192.168.127访问， 也可被localhost访问
3. 设置监听套接字
    sockfd.listen(n)
    功能：将套接字设置为监听套接字，创建监听队列
    参数：n表示监听队列大小
    * 一个监听套接字可以连接多个客户端套接字
4. 等待处理客户端连接请求
    connfd, addr = sockfd.accept()
    功能：阻塞等待处理客户端连接
    返回值：connfd->客户端连接套接字    addr->连接的客户端地址
    *阻塞函数：程序运行过程中遇到阻塞函数则暂停运行，直到某种阻塞条件达成再继续运行
5. 消息收发
    data = connfd.recv(buffersize)
    功能：接收对应客户端消息
    参数：buffersize -> 一次最多接收多少字节
    返回值：接收到到内容
    *如果没有消息则会阻塞
    n = connfd.send(data)
    功能：发送消息给对应客户端
    参数：要发送到内容，必须是bytes格式
    返回值：返回实际发送消息的大小
6.关闭套接字
    sockfd.close()
    功能：关闭套接字

二· TCP套接字客户端编程：（详情见—>TCP_Client.png) （代码->TCP_Client.py）:
1. 创建套接字
    *必须相同类型的套接字才能通信
2. 建立连接
    sockfd.connect(servr_addr)
    功能：建立连接
    参数：tuple -> addr
3. 消息收发
4. 关闭套接字

三· TCP总结
TCP_Server总结：
socket() ---> bind() ---> listen() ---> accept() --->recv/send ---> close()
TCP_Client总结：
socket() ---> connect() ---> send/recv ---> close()

socket套接字传输注意事项：
    1. listen socket存在时，client即可发起连接，但是最终连接处理需要accept进行处理
    2. 如果连接的另一端退出， 则recv会立即返回空子串不在阻塞
    3. 当连接当另一端退出的时候， 再试图send就会产生BrokenPipeError
网络收发缓冲区：
缓冲区作用：协调收发（处理）速度；减少交互次数
send和recv实际上是和缓冲区进行交互，发送缓冲区满时就无法发送，接收缓冲区满时recv就会阻塞
data = connfd.recv(1024).decode()   这里1024就是缓recv冲区的大小 

TCP粘包：
产生原因：TCP_socket以字节流方式传输，没有消息边界。发送和接收并不能保证每次发送都及时的被接收
影响：如果每次发送内容表达一个独立的含义，此时可能需要处理粘包防止产生歧义
处理方法：
    1. 每次发送的消息添加结尾标志（人为增加消息边界）
    2. 发送数据结构体（相对复杂）
    3. 协调收发速度，每次发送后都预留接收时间（相对简单）

四· UDP套接字服务端编程：（详情见—>UDP_Server.png) （代码->UDP_Server.py）
1. 创建数据报套接字
sockfd = socket(AF_INET, SOCK_DGRAM)
2. 绑定地址
sockfd.bind(addr)
3.消息收发
data, addr = sockfd.recvfrom(buffersize)
功能：接收UDP消息
参数：每次最多接收多大的消息
返回值：data -> 接收到的数据    addr -> 消息发送端的地址
sockfd.sendto(data, addr)
功能：发送UDP消息
参数： data -> 发送的消息（bytes格式）  addr -> 目标地址
返回值：发送的字节数
***一次只接收一个数据报，如果接受的数据报大于buffersize，则会丢失部分数据
4. 关闭套接字
sockfd.close()

五· UDP套接字客户端编程：（详情见—>UDP_Client.png) （代码->UDP_Client.py）:
1. 创建数据报套接字
socket(AF_INET, SOCK_DGRAM)
2. 消息收发
recvfrom/sendto
3. 关闭套接字
close()

cookie：
sys.argv属性
    功能：获取命令行参数， 得到一个列表
    命令本身是argv[0], 后面的参数从argv[1]开始， 默认以空格分隔，使用引号引起来的内容算作一个整体。
改变argv.py权限：代码前面加上：#!/usr/bin/env python3 然后command：chmod 766 argv.py

六· TCP_socket与UDP_socket区别（编程角度上
1. TCP：流式（stream）套接字使用字节流的方式传输    UDP：数据报套接字以数据报形式传输数据
2. TCP会有粘包现象  UDP有消息边界不会形成粘包
3. TCP可以保障数据传输完整性    UDP则不保证
4. TCP需要进行listen, accept等操作  UDP不需要
5. TCP收发消息使用新的套接字recv, send     UDP使用recvfrom, sendto

七· 补充函数
sendall(data)   #对比send(), sendall需要全部发送出去，要么就一点也不发送
功能：发送TCP消息
参数：要发送的内容，bytes格式
返回值：成功->none  失败->产生异常

------------------------------------------------套接字对象------------------------------------------------------
常见套接字方程：
s代表一个套接字
s.family: 获取套接字地址族类型
s.type: 获取套接字类型
s.getsockname(): 获取套接字的绑定地址
s.fileno(): 获取套接字的文件描述符  文件描述符：每一个IO事件操作系统都会分配一个不同的正整数作为编号，该正整数即为这个IO文件描述符
    >>> import sys
    >>> sys.stdin.fileno()
    0
    >>> sys.stdout.fileno()
    1
    >>> sys.stderr.fileno()
    2
*文件描述符是操作系统识别IO的唯一标准
s.getpeername(): 获取客户端连接套接字的对应地址
s.setsockopt(level, option, value)
    功能：设置套接字选项
    参数：
        level 选项类别: SOL_SOCKET   
        option 具体选项    
        value 选项值
s.getsockopt(level, option)
    功能：获取套接字选项
    参数：
        level 选项类别: SOL_SOCKET   
        option 具体选项    
    返回值：选项值
*如果要设置套接字选项，最好在创建套接字之后立即设置

-----------------------------------------------应用------------------------------------------------------
UDP应用之广播：
广播：一点发送，多点接收
广播地址：一个网段内有一个指定的广播地址，是该网段的最大地址 192.168.137.127

TCP应用之http传输
http协议：超文本传输协议，是一个应用层协议
用途：网页数据的传输；数据传输的方法
特点：
    1.应用层协议，传输层使用tcp
    2.简单，灵活，多种语言都有http相关操作接口
    3.无状态的协议，即不记录用户传输信息
    4.http1.1   支持持久连接
一端通过http请求的格式发送具体请求内容，另一端接收http请求，按照协议格式解析。获取真实请求后按照http协议响应格式组织回复内容，回发给请求方，完成一次数据交互。
http请求：
    请求行：具体的请求类别和请求内容
    格式：GET   /   HTTP/1.1
    请求类别：GET POST HEAD PUT DELETE CONNECT TRACE OPTIONS    
http响应:
    格式：
    响应码：
        1xx: 提示信息，表示请求成功
        2xx: 响应成功 比如，200OK
        3xx: 响应需要重定向
        4xx: 客户端错误 比如, 404notfound
        5xx: 服务端错误

-----------------------------------------------I/O------------------------------------------------------
input/output: 在内存中存在数据交换的操作都可以认为是IO操作
例如：
    和终端交互：input   print
    和磁盘交互：read    write
    和网络交互：recv    send
IO密集型程序：在程序执行过程中存在大量IO操作，而cpu运算操作较少，例如：套接字，文件读写   *消耗cpu少，运行效率较低
CPU(计算)密集型程序：在程序执行过程中CPU运算较多，而IO操作较少，例如：算法运算          *消耗cpu大，运行速度较快
IO分类：
    阻塞IO：IO的一种默认形态，是效率较低的一种IO情形
        阻塞情况：
        1. 某种条件没有达成造成的阻塞 e.g. accept input recv
        2. 处理IO数据传输时间较长形成的阻塞 e.g. 网络传输过程，文件读写过程
    非阻塞IO： 通过修改IO事件的属性，使其变为非阻塞状态（让一些条件阻塞函数不在阻塞）
        非阻塞IO往往和循环判断一起使用